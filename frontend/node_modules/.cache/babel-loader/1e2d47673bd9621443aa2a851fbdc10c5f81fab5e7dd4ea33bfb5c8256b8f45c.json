{"ast":null,"code":"import { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashAuthorization, hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\n/**\r\n *  The **BaseWallet** is a stream-lined implementation of a\r\n *  [[Signer]] that operates with a private key.\r\n *\r\n *  It is preferred to use the [[Wallet]] class, as it offers\r\n *  additional functionality and simplifies loading a variety\r\n *  of JSON formats, Mnemonic Phrases, etc.\r\n *\r\n *  This class may be of use for those attempting to implement\r\n *  a minimal Signer.\r\n */\nexport class BaseWallet extends AbstractSigner {\n  /**\r\n   *  The wallet address.\r\n   */\n  address;\n  #signingKey;\n  /**\r\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\r\n   *  connected to %%provider%%.\r\n   *\r\n   *  If %%provider%% is not specified, only offline methods can\r\n   *  be used.\r\n   */\n  constructor(privateKey, provider) {\n    super(provider);\n    assertArgument(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    this.#signingKey = privateKey;\n    const address = computeAddress(this.signingKey.publicKey);\n    defineProperties(this, {\n      address\n    });\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\r\n   *  The [[SigningKey]] used for signing payloads.\r\n   */\n  get signingKey() {\n    return this.#signingKey;\n  }\n  /**\r\n   *  The private key for this wallet.\r\n   */\n  get privateKey() {\n    return this.signingKey.privateKey;\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new BaseWallet(this.#signingKey, provider);\n  }\n  async signTransaction(tx) {\n    tx = copyRequest(tx);\n    // Replace any Addressable or ENS name with an address\n    const {\n      to,\n      from\n    } = await resolveProperties({\n      to: tx.to ? resolveAddress(tx.to, this) : undefined,\n      from: tx.from ? resolveAddress(tx.from, this) : undefined\n    });\n    if (to != null) {\n      tx.to = to;\n    }\n    if (from != null) {\n      tx.from = from;\n    }\n    if (tx.from != null) {\n      assertArgument(getAddress(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n      delete tx.from;\n    }\n    // Build the transaction\n    const btx = Transaction.from(tx);\n    btx.signature = this.signingKey.sign(btx.unsignedHash);\n    return btx.serialized;\n  }\n  async signMessage(message) {\n    return this.signMessageSync(message);\n  }\n  // @TODO: Add a secialized signTx and signTyped sync that enforces\n  // all parameters are known?\n  /**\r\n   *  Returns the signature for %%message%% signed with this wallet.\r\n   */\n  signMessageSync(message) {\n    return this.signingKey.sign(hashMessage(message)).serialized;\n  }\n  /**\r\n   *  Returns the Authorization for %%auth%%.\r\n   */\n  authorizeSync(auth) {\n    assertArgument(typeof auth.address === \"string\", \"invalid address for authorizeSync\", \"auth.address\", auth);\n    const signature = this.signingKey.sign(hashAuthorization(auth));\n    return Object.assign({}, {\n      address: getAddress(auth.address),\n      nonce: getBigInt(auth.nonce || 0),\n      chainId: getBigInt(auth.chainId || 0)\n    }, {\n      signature\n    });\n  }\n  /**\r\n   *  Resolves to the Authorization for %%auth%%.\r\n   */\n  async authorize(auth) {\n    auth = Object.assign({}, auth, {\n      address: await resolveAddress(auth.address, this)\n    });\n    return this.authorizeSync(await this.populateAuthorization(auth));\n  }\n  async signTypedData(domain, types, value) {\n    // Populate any ENS names\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async name => {\n      // @TODO: this should use resolveName; addresses don't\n      //        need a provider\n      assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"resolveName\",\n        info: {\n          name\n        }\n      });\n      const address = await this.provider.resolveName(name);\n      assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n        value: name\n      });\n      return address;\n    });\n    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n  }\n}","map":{"version":3,"names":["getAddress","resolveAddress","hashAuthorization","hashMessage","TypedDataEncoder","AbstractSigner","copyRequest","computeAddress","Transaction","defineProperties","getBigInt","resolveProperties","assert","assertArgument","BaseWallet","address","signingKey","constructor","privateKey","provider","sign","publicKey","connect","signTransaction","tx","to","from","undefined","btx","signature","unsignedHash","serialized","signMessage","message","signMessageSync","authorizeSync","auth","Object","assign","nonce","chainId","authorize","populateAuthorization","signTypedData","domain","types","value","populated","resolveNames","name","operation","info","resolveName","hash"],"sources":["D:\\GitHub\\Document_verifier_project\\frontend\\node_modules\\ethers\\src.ts\\wallet\\base-wallet.ts"],"sourcesContent":["import { getAddress, resolveAddress } from \"../address/index.js\";\r\nimport {\r\n    hashAuthorization, hashMessage, TypedDataEncoder\r\n} from \"../hash/index.js\";\r\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\r\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\r\nimport {\r\n    defineProperties, getBigInt, resolveProperties, assert, assertArgument\r\n} from \"../utils/index.js\";\r\n\r\nimport type { SigningKey } from \"../crypto/index.js\";\r\nimport type {\r\n    AuthorizationRequest, TypedDataDomain, TypedDataField\r\n} from \"../hash/index.js\";\r\nimport type { Provider, TransactionRequest } from \"../providers/index.js\";\r\nimport type { Authorization, TransactionLike } from \"../transaction/index.js\";\r\n\r\n\r\n/**\r\n *  The **BaseWallet** is a stream-lined implementation of a\r\n *  [[Signer]] that operates with a private key.\r\n *\r\n *  It is preferred to use the [[Wallet]] class, as it offers\r\n *  additional functionality and simplifies loading a variety\r\n *  of JSON formats, Mnemonic Phrases, etc.\r\n *\r\n *  This class may be of use for those attempting to implement\r\n *  a minimal Signer.\r\n */\r\nexport class BaseWallet extends AbstractSigner {\r\n    /**\r\n     *  The wallet address.\r\n     */\r\n    readonly address!: string;\r\n\r\n    readonly #signingKey: SigningKey;\r\n\r\n    /**\r\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\r\n     *  connected to %%provider%%.\r\n     *\r\n     *  If %%provider%% is not specified, only offline methods can\r\n     *  be used.\r\n     */\r\n    constructor(privateKey: SigningKey, provider?: null | Provider) {\r\n        super(provider);\r\n\r\n        assertArgument(privateKey && typeof(privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\r\n\r\n        this.#signingKey = privateKey;\r\n\r\n        const address = computeAddress(this.signingKey.publicKey);\r\n        defineProperties<BaseWallet>(this, { address });\r\n    }\r\n\r\n    // Store private values behind getters to reduce visibility\r\n    // in console.log\r\n\r\n    /**\r\n     *  The [[SigningKey]] used for signing payloads.\r\n     */\r\n    get signingKey(): SigningKey { return this.#signingKey; }\r\n\r\n    /**\r\n     *  The private key for this wallet.\r\n     */\r\n    get privateKey(): string { return this.signingKey.privateKey; }\r\n\r\n    async getAddress(): Promise<string> { return this.address; }\r\n\r\n    connect(provider: null | Provider): BaseWallet {\r\n        return new BaseWallet(this.#signingKey, provider);\r\n    }\r\n\r\n    async signTransaction(tx: TransactionRequest): Promise<string> {\r\n        tx = copyRequest(tx);\r\n\r\n        // Replace any Addressable or ENS name with an address\r\n        const { to, from } = await resolveProperties({\r\n            to: (tx.to ? resolveAddress(tx.to, this): undefined),\r\n            from: (tx.from ? resolveAddress(tx.from, this): undefined)\r\n        });\r\n\r\n        if (to != null) { tx.to = to; }\r\n        if (from != null) { tx.from = from; }\r\n\r\n        if (tx.from != null) {\r\n            assertArgument(getAddress(<string>(tx.from)) === this.address,\r\n                \"transaction from address mismatch\", \"tx.from\", tx.from);\r\n            delete tx.from;\r\n        }\r\n\r\n        // Build the transaction\r\n        const btx = Transaction.from(<TransactionLike<string>>tx);\r\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\r\n\r\n        return btx.serialized;\r\n    }\r\n\r\n    async signMessage(message: string | Uint8Array): Promise<string> {\r\n        return this.signMessageSync(message);\r\n    }\r\n\r\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\r\n    // all parameters are known?\r\n    /**\r\n     *  Returns the signature for %%message%% signed with this wallet.\r\n     */\r\n    signMessageSync(message: string | Uint8Array): string {\r\n        return this.signingKey.sign(hashMessage(message)).serialized;\r\n    }\r\n\r\n    /**\r\n     *  Returns the Authorization for %%auth%%.\r\n     */\r\n    authorizeSync(auth: AuthorizationRequest): Authorization {\r\n        assertArgument(typeof(auth.address) === \"string\",\r\n          \"invalid address for authorizeSync\", \"auth.address\", auth);\r\n\r\n        const signature = this.signingKey.sign(hashAuthorization(auth));\r\n        return Object.assign({ }, {\r\n            address: getAddress(auth.address),\r\n            nonce: getBigInt(auth.nonce || 0),\r\n            chainId: getBigInt(auth.chainId || 0),\r\n        }, { signature });\r\n    }\r\n\r\n    /**\r\n     *  Resolves to the Authorization for %%auth%%.\r\n     */\r\n    async authorize(auth: AuthorizationRequest): Promise<Authorization> {\r\n        auth = Object.assign({ }, auth, {\r\n            address: await resolveAddress(auth.address, this)\r\n        });\r\n        return this.authorizeSync(await this.populateAuthorization(auth));\r\n    }\r\n\r\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\r\n\r\n        // Populate any ENS names\r\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name: string) => {\r\n            // @TODO: this should use resolveName; addresses don't\r\n            //        need a provider\r\n\r\n            assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"resolveName\",\r\n                info: { name }\r\n            });\r\n\r\n            const address = await this.provider.resolveName(name);\r\n            assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\r\n                value: name\r\n            });\r\n\r\n            return address;\r\n        });\r\n\r\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}