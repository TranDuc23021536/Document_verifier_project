{"ast":null,"code":"import * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { InvalidMultiaddrError } from \"./errors.js\";\nimport { registry, V } from \"./registry.js\";\nexport function bytesToComponents(bytes) {\n  const components = [];\n  let i = 0;\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i);\n    const codec = registry.getProtocol(code);\n    const codeLength = varint.encodingLength(code);\n    const size = sizeForAddr(codec, bytes, i + codeLength);\n    let sizeLength = 0;\n    if (size > 0 && codec.size === V) {\n      sizeLength = varint.encodingLength(size);\n    }\n    const componentLength = codeLength + sizeLength + size;\n    const component = {\n      code,\n      name: codec.name,\n      bytes: bytes.subarray(i, i + componentLength)\n    };\n    if (size > 0) {\n      const valueOffset = i + codeLength + sizeLength;\n      const valueBytes = bytes.subarray(valueOffset, valueOffset + size);\n      component.value = codec.bytesToValue?.(valueBytes) ?? uint8ArrayToString(valueBytes);\n    }\n    components.push(component);\n    i += componentLength;\n  }\n  return components;\n}\nexport function componentsToBytes(components) {\n  let length = 0;\n  const bytes = [];\n  for (const component of components) {\n    if (component.bytes == null) {\n      const codec = registry.getProtocol(component.code);\n      const codecLength = varint.encodingLength(component.code);\n      let valueBytes;\n      let valueLength = 0;\n      let valueLengthLength = 0;\n      if (component.value != null) {\n        valueBytes = codec.valueToBytes?.(component.value) ?? uint8ArrayFromString(component.value);\n        valueLength = valueBytes.byteLength;\n        if (codec.size === V) {\n          valueLengthLength = varint.encodingLength(valueLength);\n        }\n      }\n      const bytes = new Uint8Array(codecLength + valueLengthLength + valueLength);\n      // encode the protocol code\n      let offset = 0;\n      varint.encodeUint8Array(component.code, bytes, offset);\n      offset += codecLength;\n      // if there is a value\n      if (valueBytes != null) {\n        // if the value has variable length, encode the length\n        if (codec.size === V) {\n          varint.encodeUint8Array(valueLength, bytes, offset);\n          offset += valueLengthLength;\n        }\n        // finally encode the value\n        bytes.set(valueBytes, offset);\n      }\n      component.bytes = bytes;\n    }\n    bytes.push(component.bytes);\n    length += component.bytes.byteLength;\n  }\n  return uint8ArrayConcat(bytes, length);\n}\nexport function stringToComponents(string) {\n  if (string.charAt(0) !== '/') {\n    throw new InvalidMultiaddrError('String multiaddr must start with \"/\"');\n  }\n  const components = [];\n  let collecting = 'protocol';\n  let value = '';\n  let protocol = '';\n  for (let i = 1; i < string.length; i++) {\n    const char = string.charAt(i);\n    if (char !== '/') {\n      if (collecting === 'protocol') {\n        protocol += string.charAt(i);\n      } else {\n        value += string.charAt(i);\n      }\n    }\n    const ended = i === string.length - 1;\n    if (char === '/' || ended) {\n      const codec = registry.getProtocol(protocol);\n      if (collecting === 'protocol') {\n        if (codec.size == null || codec.size === 0) {\n          // a protocol without an address, eg. `/tls`\n          components.push({\n            code: codec.code,\n            name: codec.name\n          });\n          value = '';\n          protocol = '';\n          collecting = 'protocol';\n          continue;\n        } else if (ended) {\n          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);\n        }\n        // continue collecting value\n        collecting = 'value';\n      } else if (collecting === 'value') {\n        const component = {\n          code: codec.code,\n          name: codec.name\n        };\n        if (codec.size != null && codec.size !== 0) {\n          if (value === '') {\n            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`);\n          }\n          component.value = codec.stringToValue?.(value) ?? value;\n        }\n        components.push(component);\n        value = '';\n        protocol = '';\n        collecting = 'protocol';\n      }\n    }\n  }\n  if (protocol !== '' && value !== '') {\n    throw new InvalidMultiaddrError('Incomplete multiaddr');\n  }\n  return components;\n}\nexport function componentsToString(components) {\n  return `/${components.flatMap(component => {\n    if (component.value == null) {\n      return component.name;\n    }\n    const codec = registry.getProtocol(component.code);\n    if (codec == null) {\n      throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`);\n    }\n    return [component.name, codec.valueToString?.(component.value) ?? component.value];\n  }).join('/')}`;\n}\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr(codec, bytes, offset) {\n  if (codec.size == null || codec.size === 0) {\n    return 0;\n  }\n  if (codec.size > 0) {\n    return codec.size / 8;\n  }\n  return varint.decode(bytes, offset);\n}","map":{"version":3,"names":["varint","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","toString","uint8ArrayToString","InvalidMultiaddrError","registry","V","bytesToComponents","bytes","components","i","length","code","decode","codec","getProtocol","codeLength","encodingLength","size","sizeForAddr","sizeLength","componentLength","component","name","subarray","valueOffset","valueBytes","value","bytesToValue","push","componentsToBytes","codecLength","valueLength","valueLengthLength","valueToBytes","byteLength","Uint8Array","offset","encodeUint8Array","set","stringToComponents","string","charAt","collecting","protocol","char","ended","stringToValue","componentsToString","flatMap","valueToString","join"],"sources":["C:\\Users\\ducal\\OneDrive\\Documents\\document-verifier\\frontend\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\@multiformats\\multiaddr\\src\\components.ts"],"sourcesContent":["import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport { registry, V } from './registry.ts'\nimport type { Component } from './index.js'\nimport type { ProtocolCodec } from './registry.ts'\n\nexport function bytesToComponents (bytes: Uint8Array): Component[] {\n  const components: Component[] = []\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const codec = registry.getProtocol(code)\n    const codeLength = varint.encodingLength(code)\n    const size = sizeForAddr(codec, bytes, i + codeLength)\n    let sizeLength = 0\n\n    if (size > 0 && codec.size === V) {\n      sizeLength = varint.encodingLength(size)\n    }\n\n    const componentLength = codeLength + sizeLength + size\n\n    const component: Component = {\n      code,\n      name: codec.name,\n      bytes: bytes.subarray(i, i + componentLength)\n    }\n\n    if (size > 0) {\n      const valueOffset = i + codeLength + sizeLength\n      const valueBytes = bytes.subarray(valueOffset, valueOffset + size)\n\n      component.value = codec.bytesToValue?.(valueBytes) ?? uint8ArrayToString(valueBytes)\n    }\n\n    components.push(component)\n\n    i += componentLength\n  }\n\n  return components\n}\n\nexport function componentsToBytes (components: Component[]): Uint8Array {\n  let length = 0\n  const bytes: Uint8Array[] = []\n\n  for (const component of components) {\n    if (component.bytes == null) {\n      const codec = registry.getProtocol(component.code)\n      const codecLength = varint.encodingLength(component.code)\n      let valueBytes: Uint8Array | undefined\n      let valueLength = 0\n      let valueLengthLength = 0\n\n      if (component.value != null) {\n        valueBytes = codec.valueToBytes?.(component.value) ?? uint8ArrayFromString(component.value)\n        valueLength = valueBytes.byteLength\n\n        if (codec.size === V) {\n          valueLengthLength = varint.encodingLength(valueLength)\n        }\n      }\n\n      const bytes = new Uint8Array(codecLength + valueLengthLength + valueLength)\n\n      // encode the protocol code\n      let offset = 0\n      varint.encodeUint8Array(component.code, bytes, offset)\n      offset += codecLength\n\n      // if there is a value\n      if (valueBytes != null) {\n        // if the value has variable length, encode the length\n        if (codec.size === V) {\n          varint.encodeUint8Array(valueLength, bytes, offset)\n          offset += valueLengthLength\n        }\n\n        // finally encode the value\n        bytes.set(valueBytes, offset)\n      }\n\n      component.bytes = bytes\n    }\n\n    bytes.push(component.bytes)\n    length += component.bytes.byteLength\n  }\n\n  return uint8ArrayConcat(bytes, length)\n}\n\nexport function stringToComponents (string: string): Component[] {\n  if (string.charAt(0) !== '/') {\n    throw new InvalidMultiaddrError('String multiaddr must start with \"/\"')\n  }\n\n  const components: Component[] = []\n  let collecting: 'protocol' | 'value' = 'protocol'\n  let value = ''\n  let protocol = ''\n\n  for (let i = 1; i < string.length; i++) {\n    const char = string.charAt(i)\n\n    if (char !== '/') {\n      if (collecting === 'protocol') {\n        protocol += string.charAt(i)\n      } else {\n        value += string.charAt(i)\n      }\n    }\n\n    const ended = i === string.length - 1\n\n    if (char === '/' || ended) {\n      const codec = registry.getProtocol(protocol)\n\n      if (collecting === 'protocol') {\n        if (codec.size == null || codec.size === 0) {\n          // a protocol without an address, eg. `/tls`\n          components.push({\n            code: codec.code,\n            name: codec.name\n          })\n\n          value = ''\n          protocol = ''\n          collecting = 'protocol'\n\n          continue\n        } else if (ended) {\n          throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n        }\n\n        // continue collecting value\n        collecting = 'value'\n      } else if (collecting === 'value') {\n        const component: Component = {\n          code: codec.code,\n          name: codec.name\n        }\n\n        if (codec.size != null && codec.size !== 0) {\n          if (value === '') {\n            throw new InvalidMultiaddrError(`Component ${protocol} was missing value`)\n          }\n\n          component.value = codec.stringToValue?.(value) ?? value\n        }\n\n        components.push(component)\n\n        value = ''\n        protocol = ''\n        collecting = 'protocol'\n      }\n    }\n  }\n\n  if (protocol !== '' && value !== '') {\n    throw new InvalidMultiaddrError('Incomplete multiaddr')\n  }\n\n  return components\n}\n\nexport function componentsToString (components: Component[]): string {\n  return `/${components.flatMap(component => {\n      if (component.value == null) {\n        return component.name\n      }\n\n      const codec = registry.getProtocol(component.code)\n\n      if (codec == null) {\n        throw new InvalidMultiaddrError(`Unknown protocol code ${component.code}`)\n      }\n\n      return [\n        component.name,\n        codec.valueToString?.(component.value) ?? component.value\n      ]\n    }).join('/')}`\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (codec: ProtocolCodec, bytes: Uint8Array, offset: number): number {\n  if (codec.size == null || codec.size === 0) {\n    return 0\n  }\n\n  if (codec.size > 0) {\n    return codec.size / 8\n  }\n\n  return varint.decode(bytes, offset)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}