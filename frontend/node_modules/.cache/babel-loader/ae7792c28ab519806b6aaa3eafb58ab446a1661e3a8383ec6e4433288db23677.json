{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { assertArgument, concat, encodeRlp, toBeArray } from \"../utils/index.js\";\n/**\r\n *  Computes the [[link-eip-7702]] authorization digest to sign.\r\n */\nexport function hashAuthorization(auth) {\n  assertArgument(typeof auth.address === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\n  return keccak256(concat([\"0x05\", encodeRlp([auth.chainId != null ? toBeArray(auth.chainId) : \"0x\", getAddress(auth.address), auth.nonce != null ? toBeArray(auth.nonce) : \"0x\"])]));\n}\n/**\r\n *  Return the address of the private key that produced\r\n *  the signature %%sig%% during signing for %%message%%.\r\n */\nexport function verifyAuthorization(auth, sig) {\n  return recoverAddress(hashAuthorization(auth), sig);\n}","map":{"version":3,"names":["getAddress","keccak256","recoverAddress","assertArgument","concat","encodeRlp","toBeArray","hashAuthorization","auth","address","chainId","nonce","verifyAuthorization","sig"],"sources":["D:\\GitHub\\Document_verifier_project\\frontend\\node_modules\\ethers\\src.ts\\hash\\authorization.ts"],"sourcesContent":["import { getAddress } from \"../address/index.js\";\r\nimport { keccak256 } from \"../crypto/index.js\";\r\nimport { recoverAddress } from \"../transaction/index.js\";\r\nimport {\r\n    assertArgument, concat, encodeRlp, toBeArray\r\n} from \"../utils/index.js\";\r\n\r\nimport type { Addressable } from \"../address/index.js\";\r\nimport type { SignatureLike } from \"../crypto/index.js\";\r\nimport type { BigNumberish, Numeric } from \"../utils/index.js\";\r\n\r\nexport interface AuthorizationRequest {\r\n    address: string | Addressable;\r\n    nonce?: Numeric;\r\n    chainId?: BigNumberish;\r\n}\r\n\r\n/**\r\n *  Computes the [[link-eip-7702]] authorization digest to sign.\r\n */\r\nexport function hashAuthorization(auth: AuthorizationRequest): string {\r\n    assertArgument(typeof(auth.address) === \"string\", \"invalid address for hashAuthorization\", \"auth.address\", auth);\r\n    return keccak256(concat([\r\n        \"0x05\", encodeRlp([\r\n            (auth.chainId != null) ? toBeArray(auth.chainId): \"0x\",\r\n            getAddress(auth.address),\r\n            (auth.nonce != null) ? toBeArray(auth.nonce): \"0x\",\r\n        ])\r\n    ]));\r\n}\r\n\r\n/**\r\n *  Return the address of the private key that produced\r\n *  the signature %%sig%% during signing for %%message%%.\r\n */\r\nexport function verifyAuthorization(auth: AuthorizationRequest, sig: SignatureLike): string {\r\n    return recoverAddress(hashAuthorization(auth), sig);\r\n}\r\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,qBAAqB;AAChD,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,cAAc,QAAQ,yBAAyB;AACxD,SACIC,cAAc,EAAEC,MAAM,EAAEC,SAAS,EAAEC,SAAS,QACzC,mBAAmB;AAY1B;;;AAGA,OAAM,SAAUC,iBAAiBA,CAACC,IAA0B;EACxDL,cAAc,CAAC,OAAOK,IAAI,CAACC,OAAQ,KAAK,QAAQ,EAAE,uCAAuC,EAAE,cAAc,EAAED,IAAI,CAAC;EAChH,OAAOP,SAAS,CAACG,MAAM,CAAC,CACpB,MAAM,EAAEC,SAAS,CAAC,CACbG,IAAI,CAACE,OAAO,IAAI,IAAI,GAAIJ,SAAS,CAACE,IAAI,CAACE,OAAO,CAAC,GAAE,IAAI,EACtDV,UAAU,CAACQ,IAAI,CAACC,OAAO,CAAC,EACvBD,IAAI,CAACG,KAAK,IAAI,IAAI,GAAIL,SAAS,CAACE,IAAI,CAACG,KAAK,CAAC,GAAE,IAAI,CACrD,CAAC,CACL,CAAC,CAAC;AACP;AAEA;;;;AAIA,OAAM,SAAUC,mBAAmBA,CAACJ,IAA0B,EAAEK,GAAkB;EAC9E,OAAOX,cAAc,CAACK,iBAAiB,CAACC,IAAI,CAAC,EAAEK,GAAG,CAAC;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}