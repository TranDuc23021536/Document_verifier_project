{"ast":null,"code":"import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { CID } from 'multiformats';\nimport { base64url } from 'multiformats/bases/base64';\nimport { CODE_CERTHASH, CODE_DCCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_GARLIC32, CODE_GARLIC64, CODE_HTTP, CODE_HTTP_PATH, CODE_HTTPS, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_IPCIDR, CODE_MEMORY, CODE_NOISE, CODE_ONION, CODE_ONION3, CODE_P2P, CODE_P2P_CIRCUIT, CODE_P2P_STARDUST, CODE_P2P_WEBRTC_DIRECT, CODE_P2P_WEBRTC_STAR, CODE_P2P_WEBSOCKET_STAR, CODE_QUIC, CODE_QUIC_V1, CODE_SCTP, CODE_SNI, CODE_TCP, CODE_TLS, CODE_UDP, CODE_UDT, CODE_UNIX, CODE_UTP, CODE_WEBRTC, CODE_WEBRTC_DIRECT, CODE_WEBTRANSPORT, CODE_WS, CODE_WSS } from \"./constants.js\";\nimport { UnknownProtocolError, ValidationError } from \"./errors.js\";\nimport { bytes2mb, bytes2onion, bytes2port, bytesToString, ip4ToBytes, ip4ToString, ip6StringToValue, ip6ToBytes, ip6ToString, mb2bytes, onion2bytes, onion32bytes, port2bytes, stringToBytes } from \"./utils.js\";\nimport { validatePort } from \"./validation.js\";\nexport const V = -1;\nclass Registry {\n  protocolsByCode = new Map();\n  protocolsByName = new Map();\n  getProtocol(key) {\n    let codec;\n    if (typeof key === 'string') {\n      codec = this.protocolsByName.get(key);\n    } else {\n      codec = this.protocolsByCode.get(key);\n    }\n    if (codec == null) {\n      throw new UnknownProtocolError(`Protocol ${key} was unknown`);\n    }\n    return codec;\n  }\n  addProtocol(codec) {\n    this.protocolsByCode.set(codec.code, codec);\n    this.protocolsByName.set(codec.name, codec);\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.set(alias, codec);\n    });\n  }\n  removeProtocol(code) {\n    const codec = this.protocolsByCode.get(code);\n    if (codec == null) {\n      return;\n    }\n    this.protocolsByCode.delete(codec.code);\n    this.protocolsByName.delete(codec.name);\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.delete(alias);\n    });\n  }\n}\nexport const registry = new Registry();\nconst codecs = [{\n  code: CODE_IP4,\n  name: 'ip4',\n  size: 32,\n  valueToBytes: ip4ToBytes,\n  bytesToValue: ip4ToString,\n  validate: value => {\n    if (!isIPv4(value)) {\n      throw new ValidationError(`Invalid IPv4 address \"${value}\"`);\n    }\n  }\n}, {\n  code: CODE_TCP,\n  name: 'tcp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDP,\n  name: 'udp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_DCCP,\n  name: 'dccp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_IP6,\n  name: 'ip6',\n  size: 128,\n  valueToBytes: ip6ToBytes,\n  bytesToValue: ip6ToString,\n  stringToValue: ip6StringToValue,\n  validate: value => {\n    if (!isIPv6(value)) {\n      throw new ValidationError(`Invalid IPv6 address \"${value}\"`);\n    }\n  }\n}, {\n  code: CODE_IP6ZONE,\n  name: 'ip6zone',\n  size: V\n}, {\n  code: CODE_IPCIDR,\n  name: 'ipcidr',\n  size: 8,\n  bytesToValue: bytesToString('base10'),\n  valueToBytes: stringToBytes('base10')\n}, {\n  code: CODE_DNS,\n  name: 'dns',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS4,\n  name: 'dns4',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS6,\n  name: 'dns6',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNSADDR,\n  name: 'dnsaddr',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_SCTP,\n  name: 'sctp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDT,\n  name: 'udt'\n}, {\n  code: CODE_UTP,\n  name: 'utp'\n}, {\n  code: CODE_UNIX,\n  name: 'unix',\n  size: V,\n  path: true,\n  stringToValue: str => decodeURIComponent(str),\n  valueToString: val => encodeURIComponent(val)\n}, {\n  code: CODE_P2P,\n  name: 'p2p',\n  aliases: ['ipfs'],\n  size: V,\n  bytesToValue: bytesToString('base58btc'),\n  valueToBytes: val => {\n    if (val.startsWith('Q') || val.startsWith('1')) {\n      return stringToBytes('base58btc')(val);\n    }\n    return CID.parse(val).multihash.bytes;\n  }\n}, {\n  code: CODE_ONION,\n  name: 'onion',\n  size: 96,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion2bytes\n}, {\n  code: CODE_ONION3,\n  name: 'onion3',\n  size: 296,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion32bytes\n}, {\n  code: CODE_GARLIC64,\n  name: 'garlic64',\n  size: V\n}, {\n  code: CODE_GARLIC32,\n  name: 'garlic32',\n  size: V\n}, {\n  code: CODE_TLS,\n  name: 'tls'\n}, {\n  code: CODE_SNI,\n  name: 'sni',\n  size: V\n}, {\n  code: CODE_NOISE,\n  name: 'noise'\n}, {\n  code: CODE_QUIC,\n  name: 'quic'\n}, {\n  code: CODE_QUIC_V1,\n  name: 'quic-v1'\n}, {\n  code: CODE_WEBTRANSPORT,\n  name: 'webtransport'\n}, {\n  code: CODE_CERTHASH,\n  name: 'certhash',\n  size: V,\n  bytesToValue: bytes2mb(base64url),\n  valueToBytes: mb2bytes\n}, {\n  code: CODE_HTTP,\n  name: 'http'\n}, {\n  code: CODE_HTTP_PATH,\n  name: 'http-path',\n  size: V,\n  stringToValue: str => `/${decodeURIComponent(str)}`,\n  valueToString: val => encodeURIComponent(val.substring(1))\n}, {\n  code: CODE_HTTPS,\n  name: 'https'\n}, {\n  code: CODE_WS,\n  name: 'ws'\n}, {\n  code: CODE_WSS,\n  name: 'wss'\n}, {\n  code: CODE_P2P_WEBSOCKET_STAR,\n  name: 'p2p-websocket-star'\n}, {\n  code: CODE_P2P_STARDUST,\n  name: 'p2p-stardust'\n}, {\n  code: CODE_P2P_WEBRTC_STAR,\n  name: 'p2p-webrtc-star'\n}, {\n  code: CODE_P2P_WEBRTC_DIRECT,\n  name: 'p2p-webrtc-direct'\n}, {\n  code: CODE_WEBRTC_DIRECT,\n  name: 'webrtc-direct'\n}, {\n  code: CODE_WEBRTC,\n  name: 'webrtc'\n}, {\n  code: CODE_P2P_CIRCUIT,\n  name: 'p2p-circuit'\n}, {\n  code: CODE_MEMORY,\n  name: 'memory',\n  size: V\n}];\ncodecs.forEach(codec => {\n  registry.addProtocol(codec);\n});","map":{"version":3,"names":["isIPv4","isIPv6","CID","base64url","CODE_CERTHASH","CODE_DCCP","CODE_DNS","CODE_DNS4","CODE_DNS6","CODE_DNSADDR","CODE_GARLIC32","CODE_GARLIC64","CODE_HTTP","CODE_HTTP_PATH","CODE_HTTPS","CODE_IP4","CODE_IP6","CODE_IP6ZONE","CODE_IPCIDR","CODE_MEMORY","CODE_NOISE","CODE_ONION","CODE_ONION3","CODE_P2P","CODE_P2P_CIRCUIT","CODE_P2P_STARDUST","CODE_P2P_WEBRTC_DIRECT","CODE_P2P_WEBRTC_STAR","CODE_P2P_WEBSOCKET_STAR","CODE_QUIC","CODE_QUIC_V1","CODE_SCTP","CODE_SNI","CODE_TCP","CODE_TLS","CODE_UDP","CODE_UDT","CODE_UNIX","CODE_UTP","CODE_WEBRTC","CODE_WEBRTC_DIRECT","CODE_WEBTRANSPORT","CODE_WS","CODE_WSS","UnknownProtocolError","ValidationError","bytes2mb","bytes2onion","bytes2port","bytesToString","ip4ToBytes","ip4ToString","ip6StringToValue","ip6ToBytes","ip6ToString","mb2bytes","onion2bytes","onion32bytes","port2bytes","stringToBytes","validatePort","V","Registry","protocolsByCode","Map","protocolsByName","getProtocol","key","codec","get","addProtocol","set","code","name","aliases","forEach","alias","removeProtocol","delete","registry","codecs","size","valueToBytes","bytesToValue","validate","value","stringToValue","resolvable","path","str","decodeURIComponent","valueToString","val","encodeURIComponent","startsWith","parse","multihash","bytes","substring"],"sources":["C:\\Users\\ducal\\OneDrive\\Documents\\document-verifier\\frontend\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\@multiformats\\multiaddr\\src\\registry.ts"],"sourcesContent":["import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { CID } from 'multiformats'\nimport { base64url } from 'multiformats/bases/base64'\nimport { CODE_CERTHASH, CODE_DCCP, CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_GARLIC32, CODE_GARLIC64, CODE_HTTP, CODE_HTTP_PATH, CODE_HTTPS, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_IPCIDR, CODE_MEMORY, CODE_NOISE, CODE_ONION, CODE_ONION3, CODE_P2P, CODE_P2P_CIRCUIT, CODE_P2P_STARDUST, CODE_P2P_WEBRTC_DIRECT, CODE_P2P_WEBRTC_STAR, CODE_P2P_WEBSOCKET_STAR, CODE_QUIC, CODE_QUIC_V1, CODE_SCTP, CODE_SNI, CODE_TCP, CODE_TLS, CODE_UDP, CODE_UDT, CODE_UNIX, CODE_UTP, CODE_WEBRTC, CODE_WEBRTC_DIRECT, CODE_WEBTRANSPORT, CODE_WS, CODE_WSS } from './constants.ts'\nimport { UnknownProtocolError, ValidationError } from './errors.ts'\nimport { bytes2mb, bytes2onion, bytes2port, bytesToString, ip4ToBytes, ip4ToString, ip6StringToValue, ip6ToBytes, ip6ToString, mb2bytes, onion2bytes, onion32bytes, port2bytes, stringToBytes } from './utils.ts'\nimport { validatePort } from './validation.ts'\nimport type { Registry as RegistryInterface } from './index.ts'\n\nexport const V = -1\n\nexport interface ProtocolCodec {\n  /**\n   * A numeric code that will be used in the binary representation of the tuple.\n   */\n  code: number\n\n  /**\n   * A string name that will be used in the string representation of the addr.\n   */\n  name: string\n\n  /**\n   * Size defines the expected length of the address part of the tuple - valid\n   * values are `-1` (or the `V` constant) for variable length (this will be\n   * varint encoded in the binary representation), `0` for no address part or a\n   * number that represents a fixed-length address.\n   */\n  size?: number\n\n  /**\n   * If this protocol is a path protocol.\n   *\n   * @deprecated This will be removed in a future release\n   */\n  path?: boolean\n\n  /**\n   * If this protocol can be resolved using configured resolvers.\n   *\n   * @deprecated This will be removed in a future release\n   */\n  resolvable?: boolean\n\n  /**\n   * If specified this protocol codec will also be used to decode tuples with\n   * these names from string multiaddrs.\n   */\n  aliases?: string[]\n\n  /**\n   * Where the multiaddr has been encoded as a string, decode the value if\n   * necessary, unescaping any escaped values\n   */\n  stringToValue?(value: string): string\n\n  /**\n   * To encode the multiaddr as a string, escape any necessary values\n   */\n  valueToString?(value: string): string\n\n  /**\n   * To encode the multiaddr as bytes, convert the value to bytes\n   */\n  valueToBytes?(value: string): Uint8Array\n\n  /**\n   * To decode bytes to a multiaddr, convert the value bytes to a string\n   */\n  bytesToValue?(bytes: Uint8Array): string\n\n  /**\n   * Perform any necessary validation on the string value\n   */\n  validate?(value: string): void\n}\n\nclass Registry implements RegistryInterface {\n  private protocolsByCode = new Map<number, ProtocolCodec>()\n  private protocolsByName = new Map<string, ProtocolCodec>()\n\n  getProtocol (key: string | number): ProtocolCodec {\n    let codec: ProtocolCodec | undefined\n\n    if (typeof key === 'string') {\n      codec = this.protocolsByName.get(key)\n    } else {\n      codec = this.protocolsByCode.get(key)\n    }\n\n    if (codec == null) {\n      throw new UnknownProtocolError(`Protocol ${key} was unknown`)\n    }\n\n    return codec\n  }\n\n  addProtocol (codec: ProtocolCodec): void {\n    this.protocolsByCode.set(codec.code, codec)\n    this.protocolsByName.set(codec.name, codec)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.set(alias, codec)\n    })\n  }\n\n  removeProtocol (code: number): void {\n    const codec = this.protocolsByCode.get(code)\n\n    if (codec == null) {\n      return\n    }\n\n    this.protocolsByCode.delete(codec.code)\n    this.protocolsByName.delete(codec.name)\n\n    codec.aliases?.forEach(alias => {\n      this.protocolsByName.delete(alias)\n    })\n  }\n}\n\nexport const registry = new Registry()\n\nconst codecs: ProtocolCodec[] = [{\n  code: CODE_IP4,\n  name: 'ip4',\n  size: 32,\n  valueToBytes: ip4ToBytes,\n  bytesToValue: ip4ToString,\n  validate: (value) => {\n    if (!isIPv4(value)) {\n      throw new ValidationError(`Invalid IPv4 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_TCP,\n  name: 'tcp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDP,\n  name: 'udp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_DCCP,\n  name: 'dccp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_IP6,\n  name: 'ip6',\n  size: 128,\n  valueToBytes: ip6ToBytes,\n  bytesToValue: ip6ToString,\n  stringToValue: ip6StringToValue,\n  validate: (value) => {\n    if (!isIPv6(value)) {\n      throw new ValidationError(`Invalid IPv6 address \"${value}\"`)\n    }\n  }\n}, {\n  code: CODE_IP6ZONE,\n  name: 'ip6zone',\n  size: V\n}, {\n  code: CODE_IPCIDR,\n  name: 'ipcidr',\n  size: 8,\n  bytesToValue: bytesToString('base10'),\n  valueToBytes: stringToBytes('base10')\n}, {\n  code: CODE_DNS,\n  name: 'dns',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS4,\n  name: 'dns4',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNS6,\n  name: 'dns6',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_DNSADDR,\n  name: 'dnsaddr',\n  size: V,\n  resolvable: true\n}, {\n  code: CODE_SCTP,\n  name: 'sctp',\n  size: 16,\n  valueToBytes: port2bytes,\n  bytesToValue: bytes2port,\n  validate: validatePort\n}, {\n  code: CODE_UDT,\n  name: 'udt'\n}, {\n  code: CODE_UTP,\n  name: 'utp'\n}, {\n  code: CODE_UNIX,\n  name: 'unix',\n  size: V,\n  path: true,\n  stringToValue: (str) => decodeURIComponent(str),\n  valueToString: (val) => encodeURIComponent(val)\n}, {\n  code: CODE_P2P,\n  name: 'p2p',\n  aliases: ['ipfs'],\n  size: V,\n  bytesToValue: bytesToString('base58btc'),\n  valueToBytes: (val) => {\n    if (val.startsWith('Q') || val.startsWith('1')) {\n      return stringToBytes('base58btc')(val)\n    }\n\n    return CID.parse(val).multihash.bytes\n  }\n}, {\n  code: CODE_ONION,\n  name: 'onion',\n  size: 96,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion2bytes\n}, {\n  code: CODE_ONION3,\n  name: 'onion3',\n  size: 296,\n  bytesToValue: bytes2onion,\n  valueToBytes: onion32bytes\n}, {\n  code: CODE_GARLIC64,\n  name: 'garlic64',\n  size: V\n}, {\n  code: CODE_GARLIC32,\n  name: 'garlic32',\n  size: V\n}, {\n  code: CODE_TLS,\n  name: 'tls'\n}, {\n  code: CODE_SNI,\n  name: 'sni',\n  size: V\n}, {\n  code: CODE_NOISE,\n  name: 'noise'\n}, {\n  code: CODE_QUIC,\n  name: 'quic'\n}, {\n  code: CODE_QUIC_V1,\n  name: 'quic-v1'\n}, {\n  code: CODE_WEBTRANSPORT,\n  name: 'webtransport'\n}, {\n  code: CODE_CERTHASH,\n  name: 'certhash',\n  size: V,\n  bytesToValue: bytes2mb(base64url),\n  valueToBytes: mb2bytes\n}, {\n  code: CODE_HTTP,\n  name: 'http'\n}, {\n  code: CODE_HTTP_PATH,\n  name: 'http-path',\n  size: V,\n  stringToValue: (str) => `/${decodeURIComponent(str)}`,\n  valueToString: (val) => encodeURIComponent(val.substring(1))\n}, {\n  code: CODE_HTTPS,\n  name: 'https'\n}, {\n  code: CODE_WS,\n  name: 'ws'\n}, {\n  code: CODE_WSS,\n  name: 'wss'\n}, {\n  code: CODE_P2P_WEBSOCKET_STAR,\n  name: 'p2p-websocket-star'\n}, {\n  code: CODE_P2P_STARDUST,\n  name: 'p2p-stardust'\n}, {\n  code: CODE_P2P_WEBRTC_STAR,\n  name: 'p2p-webrtc-star'\n}, {\n  code: CODE_P2P_WEBRTC_DIRECT,\n  name: 'p2p-webrtc-direct'\n}, {\n  code: CODE_WEBRTC_DIRECT,\n  name: 'webrtc-direct'\n}, {\n  code: CODE_WEBRTC,\n  name: 'webrtc'\n}, {\n  code: CODE_P2P_CIRCUIT,\n  name: 'p2p-circuit'\n}, {\n  code: CODE_MEMORY,\n  name: 'memory',\n  size: V\n}]\n\ncodecs.forEach(codec => {\n  registry.addProtocol(codec)\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}