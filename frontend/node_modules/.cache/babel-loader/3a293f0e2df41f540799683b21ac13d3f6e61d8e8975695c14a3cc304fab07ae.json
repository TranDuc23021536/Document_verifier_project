{"ast":null,"code":"import * as Digest from './digest.js';\nconst DEFAULT_MIN_DIGEST_LENGTH = 20;\nexport function from({\n  name,\n  code,\n  encode,\n  minDigestLength,\n  maxDigestLength\n}) {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher {\n  name;\n  code;\n  encode;\n  minDigestLength;\n  maxDigestLength;\n  constructor(name, code, encode, minDigestLength, maxDigestLength) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;\n    this.maxDigestLength = maxDigestLength;\n  }\n  digest(input, options) {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);\n      }\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);\n      }\n    }\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate);\n      }\n      return result.then(digest => createDigest(digest, this.code, options?.truncate));\n    } else {\n      throw Error('Unknown type, must be binary type');\n      /* c8 ignore next 1 */\n    }\n  }\n}\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest(digest, code, truncate) {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`);\n    }\n    digest = digest.subarray(0, truncate);\n  }\n  return Digest.create(code, digest);\n}","map":{"version":3,"names":["Digest","DEFAULT_MIN_DIGEST_LENGTH","from","name","code","encode","minDigestLength","maxDigestLength","Hasher","constructor","digest","input","options","truncate","Error","Uint8Array","result","createDigest","then","byteLength","subarray","create"],"sources":["C:\\Users\\ducal\\OneDrive\\Documents\\document-verifier\\frontend\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\multiformats\\src\\hashes\\hasher.ts"],"sourcesContent":["import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,aAAa;AAKrC,MAAMC,yBAAyB,GAAG,EAAE;AAqBpC,OAAM,SAAUC,IAAIA,CAA6C;EAAEC,IAAI;EAAEC,IAAI;EAAEC,MAAM;EAAEC,eAAe;EAAEC;AAAe,CAA0B;EAC/I,OAAO,IAAIC,MAAM,CAACL,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAEC,eAAe,EAAEC,eAAe,CAAC;AACzE;AAgBA;;;;AAIA,OAAM,MAAOC,MAAM;EACRL,IAAI;EACJC,IAAI;EACJC,MAAM;EACNC,eAAe;EACfC,eAAe;EAExBE,YAAaN,IAAU,EAAEC,IAAU,EAAEC,MAAgD,EAAEC,eAAwB,EAAEC,eAAwB;IACvI,IAAI,CAACJ,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,eAAe,GAAGA,eAAe,IAAIL,yBAAyB;IACnE,IAAI,CAACM,eAAe,GAAGA,eAAe;EACxC;EAEAG,MAAMA,CAAEC,KAAiB,EAAEC,OAAuB;IAChD,IAAIA,OAAO,EAAEC,QAAQ,IAAI,IAAI,EAAE;MAC7B,IAAID,OAAO,CAACC,QAAQ,GAAG,IAAI,CAACP,eAAe,EAAE;QAC3C,MAAM,IAAIQ,KAAK,CAAC,6DAA6D,IAAI,CAACR,eAAe,EAAE,CAAC;MACtG;MAEA,IAAI,IAAI,CAACC,eAAe,IAAI,IAAI,IAAIK,OAAO,CAACC,QAAQ,GAAG,IAAI,CAACN,eAAe,EAAE;QAC3E,MAAM,IAAIO,KAAK,CAAC,0DAA0D,IAAI,CAACP,eAAe,EAAE,CAAC;MACnG;IACF;IAEA,IAAII,KAAK,YAAYI,UAAU,EAAE;MAC/B,MAAMC,MAAM,GAAG,IAAI,CAACX,MAAM,CAACM,KAAK,CAAC;MAEjC,IAAIK,MAAM,YAAYD,UAAU,EAAE;QAChC,OAAOE,YAAY,CAACD,MAAM,EAAE,IAAI,CAACZ,IAAI,EAAEQ,OAAO,EAAEC,QAAQ,CAAC;MAC3D;MAEA,OAAOG,MAAM,CAACE,IAAI,CAACR,MAAM,IAAIO,YAAY,CAACP,MAAM,EAAE,IAAI,CAACN,IAAI,EAAEQ,OAAO,EAAEC,QAAQ,CAAC,CAAC;IAClF,CAAC,MAAM;MACL,MAAMC,KAAK,CAAC,mCAAmC,CAAC;MAChD;IACF;EACF;;AAGF;;;;AAIA,SAASG,YAAYA,CAAwBP,MAAkB,EAAEN,IAAU,EAAES,QAAiB;EAC5F,IAAIA,QAAQ,IAAI,IAAI,IAAIA,QAAQ,KAAKH,MAAM,CAACS,UAAU,EAAE;IACtD,IAAIN,QAAQ,GAAGH,MAAM,CAACS,UAAU,EAAE;MAChC,MAAM,IAAIL,KAAK,CAAC,0DAA0DJ,MAAM,CAACS,UAAU,EAAE,CAAC;IAChG;IAEAT,MAAM,GAAGA,MAAM,CAACU,QAAQ,CAAC,CAAC,EAAEP,QAAQ,CAAC;EACvC;EAEA,OAAOb,MAAM,CAACqB,MAAM,CAACjB,IAAI,EAAEM,MAAM,CAAC;AACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}