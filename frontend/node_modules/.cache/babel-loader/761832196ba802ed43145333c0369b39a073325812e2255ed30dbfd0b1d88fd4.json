{"ast":null,"code":"import { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { bytesToComponents, componentsToBytes, componentsToString, stringToComponents } from './components.js';\nimport { CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_P2P, CODE_P2P_CIRCUIT, CODE_TCP, CODE_UDP } from \"./constants.js\";\nimport { InvalidMultiaddrError, InvalidParametersError } from \"./errors.js\";\nimport { registry } from \"./registry.js\";\nimport { isMultiaddr, multiaddr, resolvers } from './index.js';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nexport const symbol = Symbol.for('@multiformats/multiaddr');\nconst DNS_CODES = [CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR];\nclass NoAvailableResolverError extends Error {\n  constructor(message = 'No available resolver') {\n    super(message);\n    this.name = 'NoAvailableResolverError';\n  }\n}\nfunction toComponents(addr) {\n  if (addr == null) {\n    addr = '/';\n  }\n  if (isMultiaddr(addr)) {\n    return addr.getComponents();\n  }\n  if (addr instanceof Uint8Array) {\n    return bytesToComponents(addr);\n  }\n  if (typeof addr === 'string') {\n    addr = addr.replace(/\\/(\\/)+/, '/').replace(/(\\/)+$/, '');\n    if (addr === '') {\n      addr = '/';\n    }\n    return stringToComponents(addr);\n  }\n  if (Array.isArray(addr)) {\n    return addr;\n  }\n  throw new InvalidMultiaddrError('Must be a string, Uint8Array, Component[], or another Multiaddr');\n}\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr {\n  [symbol] = true;\n  #components;\n  // cache string representation\n  #string;\n  // cache byte representation\n  #bytes;\n  constructor(addr = '/', options = {}) {\n    this.#components = toComponents(addr);\n    if (options.validate !== false) {\n      validate(this);\n    }\n  }\n  get bytes() {\n    if (this.#bytes == null) {\n      this.#bytes = componentsToBytes(this.#components);\n    }\n    return this.#bytes;\n  }\n  toString() {\n    if (this.#string == null) {\n      this.#string = componentsToString(this.#components);\n    }\n    return this.#string;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  toOptions() {\n    let family;\n    let transport;\n    let host;\n    let port;\n    let zone = '';\n    for (const {\n      code,\n      name,\n      value\n    } of this.#components) {\n      if (code === CODE_IP6ZONE) {\n        zone = `%${value ?? ''}`;\n      }\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = 'tcp';\n        port = 443;\n        host = `${value ?? ''}${zone}`;\n        family = code === CODE_DNS6 ? 6 : 4;\n      }\n      if (code === CODE_TCP || code === CODE_UDP) {\n        transport = name === 'tcp' ? 'tcp' : 'udp';\n        port = parseInt(value ?? '');\n      }\n      if (code === CODE_IP4 || code === CODE_IP6) {\n        transport = 'tcp';\n        host = `${value ?? ''}${zone}`;\n        family = code === CODE_IP6 ? 6 : 4;\n      }\n    }\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".');\n    }\n    const opts = {\n      family,\n      host,\n      transport,\n      port\n    };\n    return opts;\n  }\n  getComponents() {\n    return [...this.#components];\n  }\n  protos() {\n    return this.#components.map(({\n      code,\n      value\n    }) => {\n      const codec = registry.getProtocol(code);\n      return {\n        code,\n        size: codec.size ?? 0,\n        name: codec.name,\n        resolvable: Boolean(codec.resolvable),\n        path: Boolean(codec.path)\n      };\n    });\n  }\n  protoCodes() {\n    return this.#components.map(({\n      code\n    }) => code);\n  }\n  protoNames() {\n    return this.#components.map(({\n      name\n    }) => name);\n  }\n  tuples() {\n    return this.#components.map(({\n      code,\n      value\n    }) => {\n      if (value == null) {\n        return [code];\n      }\n      const codec = registry.getProtocol(code);\n      const output = [code];\n      if (value != null) {\n        output.push(codec.valueToBytes?.(value) ?? uint8ArrayFromString(value));\n      }\n      return output;\n    });\n  }\n  stringTuples() {\n    return this.#components.map(({\n      code,\n      value\n    }) => {\n      if (value == null) {\n        return [code];\n      }\n      return [code, value];\n    });\n  }\n  encapsulate(addr) {\n    const ma = new Multiaddr(addr);\n    return new Multiaddr([...this.#components, ...ma.getComponents()], {\n      validate: false\n    });\n  }\n  decapsulate(addr) {\n    const addrString = addr.toString();\n    const s = this.toString();\n    const i = s.lastIndexOf(addrString);\n    if (i < 0) {\n      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);\n    }\n    return new Multiaddr(s.slice(0, i), {\n      validate: false\n    });\n  }\n  decapsulateCode(code) {\n    let index;\n    for (let i = this.#components.length - 1; i > -1; i--) {\n      if (this.#components[i].code === code) {\n        index = i;\n        break;\n      }\n    }\n    return new Multiaddr(this.#components.slice(0, index), {\n      validate: false\n    });\n  }\n  getPeerId() {\n    try {\n      let tuples = [];\n      this.#components.forEach(({\n        code,\n        value\n      }) => {\n        if (code === CODE_P2P) {\n          tuples.push([code, value]);\n        }\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === CODE_P2P_CIRCUIT) {\n          tuples = [];\n        }\n      });\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop();\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1];\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc');\n        }\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc');\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n  getPath() {\n    for (const component of this.#components) {\n      const codec = registry.getProtocol(component.code);\n      if (!codec.path) {\n        continue;\n      }\n      return component.value ?? null;\n    }\n    return null;\n  }\n  equals(addr) {\n    return uint8ArrayEquals(this.bytes, addr.bytes);\n  }\n  async resolve(options) {\n    const resolvableProto = this.protos().find(p => p.resolvable);\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this];\n    }\n    const resolver = resolvers.get(resolvableProto.name);\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);\n    }\n    const result = await resolver(this, options);\n    return result.map(str => multiaddr(str));\n  }\n  nodeAddress() {\n    const options = this.toOptions();\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`);\n    }\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    };\n  }\n  isThinWaistAddress() {\n    if (this.#components.length !== 2) {\n      return false;\n    }\n    if (this.#components[0].code !== CODE_IP4 && this.#components[0].code !== CODE_IP6) {\n      return false;\n    }\n    if (this.#components[1].code !== CODE_TCP && this.#components[1].code !== CODE_UDP) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect]() {\n    return `Multiaddr(${this.toString()})`;\n  }\n}\n/**\n * Ensures all multiaddr tuples are correct. Throws if any invalid protocols or\n * values are encountered.\n */\nexport function validate(addr) {\n  addr.getComponents().forEach(component => {\n    const codec = registry.getProtocol(component.code);\n    if (component.value == null) {\n      return;\n    }\n    codec.validate?.(component.value);\n  });\n}","map":{"version":3,"names":["base58btc","CID","equals","uint8ArrayEquals","fromString","uint8ArrayFromString","toString","uint8ArrayToString","bytesToComponents","componentsToBytes","componentsToString","stringToComponents","CODE_DNS","CODE_DNS4","CODE_DNS6","CODE_DNSADDR","CODE_IP4","CODE_IP6","CODE_IP6ZONE","CODE_P2P","CODE_P2P_CIRCUIT","CODE_TCP","CODE_UDP","InvalidMultiaddrError","InvalidParametersError","registry","isMultiaddr","multiaddr","resolvers","inspect","Symbol","for","symbol","DNS_CODES","NoAvailableResolverError","Error","constructor","message","name","toComponents","addr","getComponents","Uint8Array","replace","Array","isArray","Multiaddr","components","string","bytes","options","validate","toJSON","toOptions","family","transport","host","port","zone","code","value","includes","parseInt","opts","protos","map","codec","getProtocol","size","resolvable","Boolean","path","protoCodes","protoNames","tuples","output","push","valueToBytes","stringTuples","encapsulate","ma","decapsulate","addrString","s","i","lastIndexOf","slice","decapsulateCode","index","length","getPeerId","forEach","tuple","pop","peerIdStr","decode","parse","multihash","e","getPath","component","resolve","resolvableProto","find","p","resolver","get","result","str","nodeAddress","address","isThinWaistAddress"],"sources":["C:\\Users\\ducal\\OneDrive\\Documents\\document-verifier\\frontend\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\@multiformats\\multiaddr\\src\\multiaddr.ts"],"sourcesContent":["import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToComponents, componentsToBytes, componentsToString, stringToComponents } from './components.js'\nimport { CODE_DNS, CODE_DNS4, CODE_DNS6, CODE_DNSADDR, CODE_IP4, CODE_IP6, CODE_IP6ZONE, CODE_P2P, CODE_P2P_CIRCUIT, CODE_TCP, CODE_UDP } from './constants.ts'\nimport { InvalidMultiaddrError, InvalidParametersError } from './errors.ts'\nimport { registry } from './registry.ts'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, Tuple, NodeAddress, ResolveOptions, Component } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/multiaddr')\n\nconst DNS_CODES = [\n  CODE_DNS,\n  CODE_DNS4,\n  CODE_DNS6,\n  CODE_DNSADDR\n]\n\nclass NoAvailableResolverError extends Error {\n  constructor (message = 'No available resolver') {\n    super(message)\n    this.name = 'NoAvailableResolverError'\n  }\n}\n\nfunction toComponents (addr: MultiaddrInput): Component[] {\n  if (addr == null) {\n    addr = '/'\n  }\n\n  if (isMultiaddr(addr)) {\n    return addr.getComponents()\n  }\n\n  if (addr instanceof Uint8Array) {\n    return bytesToComponents(addr)\n  }\n\n  if (typeof addr === 'string') {\n    addr = addr\n      .replace(/\\/(\\/)+/, '/')\n      .replace(/(\\/)+$/, '')\n\n    if (addr === '') {\n      addr = '/'\n    }\n\n    return stringToComponents(addr)\n  }\n\n  if (Array.isArray(addr)) {\n    return addr\n  }\n\n  throw new InvalidMultiaddrError('Must be a string, Uint8Array, Component[], or another Multiaddr')\n}\n\ninterface MultiaddrOptions {\n  validate?: boolean\n}\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  [symbol]: boolean = true\n  readonly #components: Component[]\n\n  // cache string representation\n  #string: string | undefined\n  // cache byte representation\n  #bytes: Uint8Array | undefined\n\n  constructor (addr: MultiaddrInput | Component[] = '/', options: MultiaddrOptions = {}) {\n    this.#components = toComponents(addr)\n\n    if (options.validate !== false) {\n      validate(this)\n    }\n  }\n\n  get bytes (): Uint8Array {\n    if (this.#bytes == null) {\n      this.#bytes = componentsToBytes(this.#components)\n    }\n\n    return this.#bytes\n  }\n\n  toString (): string {\n    if (this.#string == null) {\n      this.#string = componentsToString(this.#components)\n    }\n\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: 'tcp' | 'udp' | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    for (const { code, name, value } of this.#components) {\n      if (code === CODE_IP6ZONE) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = 'tcp'\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === CODE_DNS6 ? 6 : 4\n      }\n\n      if (code === CODE_TCP || code === CODE_UDP) {\n        transport = name === 'tcp' ? 'tcp' : 'udp'\n        port = parseInt(value ?? '')\n      }\n\n      if (code === CODE_IP4 || code === CODE_IP6) {\n        transport = 'tcp'\n        host = `${value ?? ''}${zone}`\n        family = code === CODE_IP6 ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  getComponents (): Component[] {\n    return [\n      ...this.#components\n    ]\n  }\n\n  protos (): Protocol[] {\n    return this.#components.map(({ code, value }) => {\n      const codec = registry.getProtocol(code)\n\n      return {\n        code,\n        size: codec.size ?? 0,\n        name: codec.name,\n        resolvable: Boolean(codec.resolvable),\n        path: Boolean(codec.path)\n      }\n    })\n  }\n\n  protoCodes (): number[] {\n    return this.#components.map(({ code }) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#components.map(({ name }) => name)\n  }\n\n  tuples (): Tuple[] {\n    return this.#components.map(({ code, value }) => {\n      if (value == null) {\n        return [code]\n      }\n\n      const codec = registry.getProtocol(code)\n      const output: Tuple = [code]\n\n      if (value != null) {\n        output.push(codec.valueToBytes?.(value) ?? uint8ArrayFromString(value))\n      }\n\n      return output\n    })\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#components.map(({ code, value }) => {\n      if (value == null) {\n        return [code]\n      }\n\n      return [code, value]\n    })\n  }\n\n  encapsulate (addr: MultiaddrInput): MultiaddrInterface {\n    const ma = new Multiaddr(addr)\n\n    return new Multiaddr([\n      ...this.#components,\n      ...ma.getComponents()\n    ], {\n      validate: false\n    })\n  }\n\n  decapsulate (addr: Multiaddr | string): MultiaddrInterface {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n\n    if (i < 0) {\n      throw new InvalidParametersError(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n\n    return new Multiaddr(s.slice(0, i), {\n      validate: false\n    })\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    let index\n\n    for (let i = this.#components.length - 1; i > -1; i--) {\n      if (this.#components[i].code === code) {\n        index = i\n        break\n      }\n    }\n\n    return new Multiaddr(this.#components.slice(0, index), {\n      validate: false\n    })\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.#components.forEach(({ code, value }) => {\n        if (code === CODE_P2P) {\n          tuples.push([code, value])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === CODE_P2P_CIRCUIT) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    for (const component of this.#components) {\n      const codec = registry.getProtocol(component.code)\n\n      if (!codec.path) {\n        continue\n      }\n\n      return component.value ?? null\n    }\n\n    return null\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`)\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (): boolean {\n    if (this.#components.length !== 2) {\n      return false\n    }\n\n    if (this.#components[0].code !== CODE_IP4 && this.#components[0].code !== CODE_IP6) {\n      return false\n    }\n\n    if (this.#components[1].code !== CODE_TCP && this.#components[1].code !== CODE_UDP) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.toString()})`\n  }\n}\n\n/**\n * Ensures all multiaddr tuples are correct. Throws if any invalid protocols or\n * values are encountered.\n */\nexport function validate (addr: Multiaddr): void {\n  addr.getComponents()\n    .forEach(component => {\n      const codec = registry.getProtocol(component.code)\n\n      if (component.value == null) {\n        return\n      }\n\n      codec.validate?.(component.value)\n    })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}