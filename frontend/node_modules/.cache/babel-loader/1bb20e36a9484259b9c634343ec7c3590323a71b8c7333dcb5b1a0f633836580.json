{"ast":null,"code":"import { isIPv4 } from '@chainsafe/is-ip';\nimport { base32 } from 'multiformats/bases/base32';\nimport { bases } from 'multiformats/basics';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { InvalidMultiaddrError } from \"./errors.js\";\nexport function bytesToString(base) {\n  return buf => {\n    return uint8ArrayToString(buf, base);\n  };\n}\nexport function stringToBytes(base) {\n  return buf => {\n    return uint8ArrayFromString(buf, base);\n  };\n}\nexport function bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset).toString();\n}\nexport function port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, typeof port === 'string' ? parseInt(port) : port);\n  return new Uint8Array(buf);\n}\nexport function onion2bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = uint8ArrayFromString(addr[0], 'base32');\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nexport function onion32bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`);\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nexport function bytes2onion(buf) {\n  const addrBytes = buf.subarray(0, buf.length - 2);\n  const portBytes = buf.subarray(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return `${addr}:${port}`;\n}\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip4ToBytes = function (ip) {\n  ip = ip.toString().trim();\n  const bytes = new Uint8Array(4);\n  ip.split(/\\./g).forEach((byte, index) => {\n    const value = parseInt(byte, 10);\n    if (isNaN(value) || value < 0 || value > 0xff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address');\n    }\n    bytes[index] = value;\n  });\n  return bytes;\n};\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip6ToBytes = function (ip) {\n  let offset = 0;\n  ip = ip.toString().trim();\n  const sections = ip.split(':', 8);\n  let i;\n  for (i = 0; i < sections.length; i++) {\n    const isv4 = isIPv4(sections[i]);\n    let v4Buffer;\n    if (isv4) {\n      v4Buffer = ip4ToBytes(sections[i]);\n      sections[i] = uint8ArrayToString(v4Buffer.subarray(0, 2), 'base16');\n    }\n    if (v4Buffer != null && ++i < 8) {\n      sections.splice(i, 0, uint8ArrayToString(v4Buffer.subarray(2, 4), 'base16'));\n    }\n  }\n  if (sections[0] === '') {\n    while (sections.length < 8) {\n      sections.unshift('0');\n    }\n  } else if (sections[sections.length - 1] === '') {\n    while (sections.length < 8) {\n      sections.push('0');\n    }\n  } else if (sections.length < 8) {\n    for (i = 0; i < sections.length && sections[i] !== ''; i++) {}\n    const argv = [i, 1];\n    for (i = 9 - sections.length; i > 0; i--) {\n      argv.push('0');\n    }\n    sections.splice.apply(sections, argv);\n  }\n  const bytes = new Uint8Array(offset + 16);\n  for (i = 0; i < sections.length; i++) {\n    if (sections[i] === '') {\n      sections[i] = '0';\n    }\n    const word = parseInt(sections[i], 16);\n    if (isNaN(word) || word < 0 || word > 0xffff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address');\n    }\n    bytes[offset++] = word >> 8 & 0xff;\n    bytes[offset++] = word & 0xff;\n  }\n  return bytes;\n};\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const ip4ToString = function (buf) {\n  if (buf.byteLength !== 4) {\n    throw new InvalidMultiaddrError('IPv4 address was incorrect length');\n  }\n  const result = [];\n  for (let i = 0; i < buf.byteLength; i++) {\n    result.push(buf[i]);\n  }\n  return result.join('.');\n};\nexport const ip6ToString = function (buf) {\n  if (buf.byteLength !== 16) {\n    throw new InvalidMultiaddrError('IPv6 address was incorrect length');\n  }\n  const result = [];\n  for (let i = 0; i < buf.byteLength; i += 2) {\n    const byte1 = buf[i];\n    const byte2 = buf[i + 1];\n    const tuple = `${byte1.toString(16).padStart(2, '0')}${byte2.toString(16).padStart(2, '0')}`;\n    result.push(tuple);\n  }\n  const ip = result.join(':');\n  try {\n    const url = new URL(`http://[${ip}]`);\n    return url.hostname.substring(1, url.hostname.length - 1);\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${ip}\"`);\n  }\n};\nexport function ip6StringToValue(str) {\n  try {\n    const url = new URL(`http://[${str}]`);\n    return url.hostname.substring(1, url.hostname.length - 1);\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${str}\"`);\n  }\n}\nconst decoders = Object.values(bases).map(c => c.decoder);\nconst anybaseDecoder = function () {\n  let acc = decoders[0].or(decoders[1]);\n  decoders.slice(2).forEach(d => acc = acc.or(d));\n  return acc;\n}();\nexport function mb2bytes(mbstr) {\n  return anybaseDecoder.decode(mbstr);\n}\nexport function bytes2mb(base) {\n  return buf => {\n    return base.encoder.encode(buf);\n  };\n}","map":{"version":3,"names":["isIPv4","base32","bases","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","toString","uint8ArrayToString","InvalidMultiaddrError","bytesToString","base","buf","stringToBytes","bytes2port","view","DataView","buffer","getUint16","byteOffset","port2bytes","port","ArrayBuffer","setUint16","parseInt","Uint8Array","onion2bytes","str","addr","split","length","Error","join","portBuf","onion32bytes","decode","bytes2onion","addrBytes","subarray","portBytes","ip4ToBytes","ip","trim","bytes","forEach","byte","index","value","isNaN","ip6ToBytes","offset","sections","i","isv4","v4Buffer","splice","unshift","push","argv","apply","word","ip4ToString","byteLength","result","ip6ToString","byte1","byte2","tuple","padStart","url","URL","hostname","substring","ip6StringToValue","decoders","Object","values","map","c","decoder","anybaseDecoder","acc","or","slice","d","mb2bytes","mbstr","bytes2mb","encoder","encode"],"sources":["C:\\Users\\ducal\\OneDrive\\Documents\\document-verifier\\frontend\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\@multiformats\\multiaddr\\src\\utils.ts"],"sourcesContent":["import { isIPv4 } from '@chainsafe/is-ip'\nimport { base32 } from 'multiformats/bases/base32'\nimport { bases } from 'multiformats/basics'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { InvalidMultiaddrError } from './errors.ts'\nimport type { MultibaseCodec } from 'multiformats'\nimport type { SupportedEncodings } from 'uint8arrays/to-string'\n\nexport function bytesToString (base: SupportedEncodings): (buf: Uint8Array) => string {\n  return (buf) => {\n    return uint8ArrayToString(buf, base)\n  }\n}\n\nexport function stringToBytes (base: SupportedEncodings): (value: string) => Uint8Array {\n  return (buf) => {\n    return uint8ArrayFromString(buf, base)\n  }\n}\n\nexport function bytes2port (buf: Uint8Array): string {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset).toString()\n}\n\nexport function port2bytes (port: string | number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, typeof port === 'string' ? parseInt(port) : port)\n\n  return new Uint8Array(buf)\n}\n\nexport function onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = uint8ArrayFromString(addr[0], 'base32')\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n\n  const portBuf = port2bytes(port)\n\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nexport function bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.subarray(0, buf.length - 2)\n  const portBytes = buf.subarray(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip4ToBytes = function (ip: string): Uint8Array {\n  ip = ip.toString().trim()\n\n  const bytes = new Uint8Array(4)\n\n  ip.split(/\\./g).forEach((byte, index) => {\n    const value = parseInt(byte, 10)\n\n    if (isNaN(value) || value < 0 || value > 0xff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[index] = value\n  })\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const ip6ToBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  const sections = ip.split(':', 8)\n\n  let i\n  for (i = 0; i < sections.length; i++) {\n    const isv4 = isIPv4(sections[i])\n    let v4Buffer: Uint8Array | undefined\n\n    if (isv4) {\n      v4Buffer = ip4ToBytes(sections[i])\n      sections[i] = uint8ArrayToString(v4Buffer.subarray(0, 2), 'base16')\n    }\n\n    if (v4Buffer != null && ++i < 8) {\n      sections.splice(i, 0, uint8ArrayToString(v4Buffer.subarray(2, 4), 'base16'))\n    }\n  }\n\n  if (sections[0] === '') {\n    while (sections.length < 8) { sections.unshift('0') }\n  } else if (sections[sections.length - 1] === '') {\n    while (sections.length < 8) { sections.push('0') }\n  } else if (sections.length < 8) {\n    for (i = 0; i < sections.length && sections[i] !== ''; i++) { }\n    const argv: [number, number, ...string[]] = [i, 1]\n    for (i = 9 - sections.length; i > 0; i--) {\n      argv.push('0')\n    }\n    sections.splice.apply(sections, argv)\n  }\n\n  const bytes = new Uint8Array(offset + 16)\n\n  for (i = 0; i < sections.length; i++) {\n    if (sections[i] === '') {\n      sections[i] = '0'\n    }\n\n    const word = parseInt(sections[i], 16)\n\n    if (isNaN(word) || word < 0 || word > 0xffff) {\n      throw new InvalidMultiaddrError('Invalid byte value in IP address')\n    }\n\n    bytes[offset++] = (word >> 8) & 0xff\n    bytes[offset++] = word & 0xff\n  }\n\n  return bytes\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const ip4ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 4) {\n    throw new InvalidMultiaddrError('IPv4 address was incorrect length')\n  }\n\n  const result = []\n\n  for (let i = 0; i < buf.byteLength; i++) {\n    result.push(buf[i])\n  }\n\n  return result.join('.')\n}\n\nexport const ip6ToString = function (buf: Uint8Array): string {\n  if (buf.byteLength !== 16) {\n    throw new InvalidMultiaddrError('IPv6 address was incorrect length')\n  }\n\n  const result: string[] = []\n\n  for (let i = 0; i < buf.byteLength; i += 2) {\n    const byte1 = buf[i]\n    const byte2 = buf[i + 1]\n\n    const tuple = `${byte1.toString(16).padStart(2, '0')}${byte2.toString(16).padStart(2, '0')}`\n\n    result.push(tuple)\n  }\n\n  const ip = result.join(':')\n\n  try {\n    const url = new URL(`http://[${ip}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${ip}\"`)\n  }\n}\n\nexport function ip6StringToValue (str: string): string {\n  try {\n    const url = new URL(`http://[${str}]`)\n\n    return url.hostname.substring(1, url.hostname.length - 1)\n  } catch {\n    throw new InvalidMultiaddrError(`Invalid IPv6 address \"${str}\"`)\n  }\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nexport function mb2bytes (mbstr: string): Uint8Array {\n  return anybaseDecoder.decode(mbstr)\n}\n\nexport function bytes2mb (base: MultibaseCodec<any>): (buf: Uint8Array) => string {\n  return (buf) => {\n    return base.encoder.encode(buf)\n  }\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,kBAAkB;AACzC,SAASC,MAAM,QAAQ,2BAA2B;AAClD,SAASC,KAAK,QAAQ,qBAAqB;AAC3C,SAASC,MAAM,IAAIC,gBAAgB,QAAQ,oBAAoB;AAC/D,SAASC,UAAU,IAAIC,oBAAoB,QAAQ,yBAAyB;AAC5E,SAASC,QAAQ,IAAIC,kBAAkB,QAAQ,uBAAuB;AACtE,SAASC,qBAAqB,QAAQ,aAAa;AAInD,OAAM,SAAUC,aAAaA,CAAEC,IAAwB;EACrD,OAAQC,GAAG,IAAI;IACb,OAAOJ,kBAAkB,CAACI,GAAG,EAAED,IAAI,CAAC;EACtC,CAAC;AACH;AAEA,OAAM,SAAUE,aAAaA,CAAEF,IAAwB;EACrD,OAAQC,GAAG,IAAI;IACb,OAAON,oBAAoB,CAACM,GAAG,EAAED,IAAI,CAAC;EACxC,CAAC;AACH;AAEA,OAAM,SAAUG,UAAUA,CAAEF,GAAe;EACzC,MAAMG,IAAI,GAAG,IAAIC,QAAQ,CAACJ,GAAG,CAACK,MAAM,CAAC;EACrC,OAAOF,IAAI,CAACG,SAAS,CAACN,GAAG,CAACO,UAAU,CAAC,CAACZ,QAAQ,EAAE;AAClD;AAEA,OAAM,SAAUa,UAAUA,CAAEC,IAAqB;EAC/C,MAAMT,GAAG,GAAG,IAAIU,WAAW,CAAC,CAAC,CAAC;EAC9B,MAAMP,IAAI,GAAG,IAAIC,QAAQ,CAACJ,GAAG,CAAC;EAC9BG,IAAI,CAACQ,SAAS,CAAC,CAAC,EAAE,OAAOF,IAAI,KAAK,QAAQ,GAAGG,QAAQ,CAACH,IAAI,CAAC,GAAGA,IAAI,CAAC;EAEnE,OAAO,IAAII,UAAU,CAACb,GAAG,CAAC;AAC5B;AAEA,OAAM,SAAUc,WAAWA,CAAEC,GAAW;EACtC,MAAMC,IAAI,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EAE3B,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,kCAAkCH,IAAI,CAACI,IAAI,CAAC,MAAM,CAAC,qCAAqC,CAAC;EAC3G;EAEA,IAAIJ,IAAI,CAAC,CAAC,CAAC,CAACE,MAAM,KAAK,EAAE,EAAE;IACzB,MAAM,IAAIC,KAAK,CAAC,+BAA+BH,IAAI,CAAC,CAAC,CAAC,2BAA2B,CAAC;EACpF;EAEA;EACA,MAAMhB,GAAG,GAAGN,oBAAoB,CAACsB,IAAI,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC;EAEnD;EACA,MAAMP,IAAI,GAAGG,QAAQ,CAACI,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAElC,IAAIP,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,KAAK,EAAE;IAC5B,MAAM,IAAIU,KAAK,CAAC,uCAAuC,CAAC;EAC1D;EAEA,MAAME,OAAO,GAAGb,UAAU,CAACC,IAAI,CAAC;EAEhC,OAAOjB,gBAAgB,CAAC,CAACQ,GAAG,EAAEqB,OAAO,CAAC,EAAErB,GAAG,CAACkB,MAAM,GAAGG,OAAO,CAACH,MAAM,CAAC;AACtE;AAEA,OAAM,SAAUI,YAAYA,CAAEP,GAAW;EACvC,MAAMC,IAAI,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EAE3B,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,kCAAkCH,IAAI,CAACI,IAAI,CAAC,MAAM,CAAC,qCAAqC,CAAC;EAC3G;EAEA,IAAIJ,IAAI,CAAC,CAAC,CAAC,CAACE,MAAM,KAAK,EAAE,EAAE;IACzB,MAAM,IAAIC,KAAK,CAAC,+BAA+BH,IAAI,CAAC,CAAC,CAAC,4BAA4B,CAAC;EACrF;EAEA;EACA,MAAMhB,GAAG,GAAGX,MAAM,CAACkC,MAAM,CAAC,IAAIP,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;EAExC;EACA,MAAMP,IAAI,GAAGG,QAAQ,CAACI,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAElC,IAAIP,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,KAAK,EAAE;IAC5B,MAAM,IAAIU,KAAK,CAAC,uCAAuC,CAAC;EAC1D;EAEA,MAAME,OAAO,GAAGb,UAAU,CAACC,IAAI,CAAC;EAEhC,OAAOjB,gBAAgB,CAAC,CAACQ,GAAG,EAAEqB,OAAO,CAAC,EAAErB,GAAG,CAACkB,MAAM,GAAGG,OAAO,CAACH,MAAM,CAAC;AACtE;AAEA,OAAM,SAAUM,WAAWA,CAAExB,GAAe;EAC1C,MAAMyB,SAAS,GAAGzB,GAAG,CAAC0B,QAAQ,CAAC,CAAC,EAAE1B,GAAG,CAACkB,MAAM,GAAG,CAAC,CAAC;EACjD,MAAMS,SAAS,GAAG3B,GAAG,CAAC0B,QAAQ,CAAC1B,GAAG,CAACkB,MAAM,GAAG,CAAC,CAAC;EAC9C,MAAMF,IAAI,GAAGpB,kBAAkB,CAAC6B,SAAS,EAAE,QAAQ,CAAC;EACpD,MAAMhB,IAAI,GAAGP,UAAU,CAACyB,SAAS,CAAC;EAClC,OAAO,GAAGX,IAAI,IAAIP,IAAI,EAAE;AAC1B;AAEA;AACA;AACA,OAAO,MAAMmB,UAAU,GAAG,SAAAA,CAAUC,EAAU;EAC5CA,EAAE,GAAGA,EAAE,CAAClC,QAAQ,EAAE,CAACmC,IAAI,EAAE;EAEzB,MAAMC,KAAK,GAAG,IAAIlB,UAAU,CAAC,CAAC,CAAC;EAE/BgB,EAAE,CAACZ,KAAK,CAAC,KAAK,CAAC,CAACe,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAI;IACtC,MAAMC,KAAK,GAAGvB,QAAQ,CAACqB,IAAI,EAAE,EAAE,CAAC;IAEhC,IAAIG,KAAK,CAACD,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,IAAI,EAAE;MAC7C,MAAM,IAAItC,qBAAqB,CAAC,kCAAkC,CAAC;IACrE;IAEAkC,KAAK,CAACG,KAAK,CAAC,GAAGC,KAAK;EACtB,CAAC,CAAC;EAEF,OAAOJ,KAAK;AACd,CAAC;AAED;AACA;AACA,OAAO,MAAMM,UAAU,GAAG,SAAAA,CAAUR,EAAU;EAC5C,IAAIS,MAAM,GAAG,CAAC;EACdT,EAAE,GAAGA,EAAE,CAAClC,QAAQ,EAAE,CAACmC,IAAI,EAAE;EAEzB,MAAMS,QAAQ,GAAGV,EAAE,CAACZ,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;EAEjC,IAAIuB,CAAC;EACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACrB,MAAM,EAAEsB,CAAC,EAAE,EAAE;IACpC,MAAMC,IAAI,GAAGrD,MAAM,CAACmD,QAAQ,CAACC,CAAC,CAAC,CAAC;IAChC,IAAIE,QAAgC;IAEpC,IAAID,IAAI,EAAE;MACRC,QAAQ,GAAGd,UAAU,CAACW,QAAQ,CAACC,CAAC,CAAC,CAAC;MAClCD,QAAQ,CAACC,CAAC,CAAC,GAAG5C,kBAAkB,CAAC8C,QAAQ,CAAChB,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC;IACrE;IAEA,IAAIgB,QAAQ,IAAI,IAAI,IAAI,EAAEF,CAAC,GAAG,CAAC,EAAE;MAC/BD,QAAQ,CAACI,MAAM,CAACH,CAAC,EAAE,CAAC,EAAE5C,kBAAkB,CAAC8C,QAAQ,CAAChB,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;IAC9E;EACF;EAEA,IAAIa,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;IACtB,OAAOA,QAAQ,CAACrB,MAAM,GAAG,CAAC,EAAE;MAAEqB,QAAQ,CAACK,OAAO,CAAC,GAAG,CAAC;IAAC;EACtD,CAAC,MAAM,IAAIL,QAAQ,CAACA,QAAQ,CAACrB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;IAC/C,OAAOqB,QAAQ,CAACrB,MAAM,GAAG,CAAC,EAAE;MAAEqB,QAAQ,CAACM,IAAI,CAAC,GAAG,CAAC;IAAC;EACnD,CAAC,MAAM,IAAIN,QAAQ,CAACrB,MAAM,GAAG,CAAC,EAAE;IAC9B,KAAKsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACrB,MAAM,IAAIqB,QAAQ,CAACC,CAAC,CAAC,KAAK,EAAE,EAAEA,CAAC,EAAE,EAAE,CAAE;IAC9D,MAAMM,IAAI,GAAkC,CAACN,CAAC,EAAE,CAAC,CAAC;IAClD,KAAKA,CAAC,GAAG,CAAC,GAAGD,QAAQ,CAACrB,MAAM,EAAEsB,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxCM,IAAI,CAACD,IAAI,CAAC,GAAG,CAAC;IAChB;IACAN,QAAQ,CAACI,MAAM,CAACI,KAAK,CAACR,QAAQ,EAAEO,IAAI,CAAC;EACvC;EAEA,MAAMf,KAAK,GAAG,IAAIlB,UAAU,CAACyB,MAAM,GAAG,EAAE,CAAC;EAEzC,KAAKE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACrB,MAAM,EAAEsB,CAAC,EAAE,EAAE;IACpC,IAAID,QAAQ,CAACC,CAAC,CAAC,KAAK,EAAE,EAAE;MACtBD,QAAQ,CAACC,CAAC,CAAC,GAAG,GAAG;IACnB;IAEA,MAAMQ,IAAI,GAAGpC,QAAQ,CAAC2B,QAAQ,CAACC,CAAC,CAAC,EAAE,EAAE,CAAC;IAEtC,IAAIJ,KAAK,CAACY,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAG,MAAM,EAAE;MAC5C,MAAM,IAAInD,qBAAqB,CAAC,kCAAkC,CAAC;IACrE;IAEAkC,KAAK,CAACO,MAAM,EAAE,CAAC,GAAIU,IAAI,IAAI,CAAC,GAAI,IAAI;IACpCjB,KAAK,CAACO,MAAM,EAAE,CAAC,GAAGU,IAAI,GAAG,IAAI;EAC/B;EAEA,OAAOjB,KAAK;AACd,CAAC;AAED;AACA,OAAO,MAAMkB,WAAW,GAAG,SAAAA,CAAUjD,GAAe;EAClD,IAAIA,GAAG,CAACkD,UAAU,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIrD,qBAAqB,CAAC,mCAAmC,CAAC;EACtE;EAEA,MAAMsD,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxC,GAAG,CAACkD,UAAU,EAAEV,CAAC,EAAE,EAAE;IACvCW,MAAM,CAACN,IAAI,CAAC7C,GAAG,CAACwC,CAAC,CAAC,CAAC;EACrB;EAEA,OAAOW,MAAM,CAAC/B,IAAI,CAAC,GAAG,CAAC;AACzB,CAAC;AAED,OAAO,MAAMgC,WAAW,GAAG,SAAAA,CAAUpD,GAAe;EAClD,IAAIA,GAAG,CAACkD,UAAU,KAAK,EAAE,EAAE;IACzB,MAAM,IAAIrD,qBAAqB,CAAC,mCAAmC,CAAC;EACtE;EAEA,MAAMsD,MAAM,GAAa,EAAE;EAE3B,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxC,GAAG,CAACkD,UAAU,EAAEV,CAAC,IAAI,CAAC,EAAE;IAC1C,MAAMa,KAAK,GAAGrD,GAAG,CAACwC,CAAC,CAAC;IACpB,MAAMc,KAAK,GAAGtD,GAAG,CAACwC,CAAC,GAAG,CAAC,CAAC;IAExB,MAAMe,KAAK,GAAG,GAAGF,KAAK,CAAC1D,QAAQ,CAAC,EAAE,CAAC,CAAC6D,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAGF,KAAK,CAAC3D,QAAQ,CAAC,EAAE,CAAC,CAAC6D,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;IAE5FL,MAAM,CAACN,IAAI,CAACU,KAAK,CAAC;EACpB;EAEA,MAAM1B,EAAE,GAAGsB,MAAM,CAAC/B,IAAI,CAAC,GAAG,CAAC;EAE3B,IAAI;IACF,MAAMqC,GAAG,GAAG,IAAIC,GAAG,CAAC,WAAW7B,EAAE,GAAG,CAAC;IAErC,OAAO4B,GAAG,CAACE,QAAQ,CAACC,SAAS,CAAC,CAAC,EAAEH,GAAG,CAACE,QAAQ,CAACzC,MAAM,GAAG,CAAC,CAAC;EAC3D,CAAC,CAAC,MAAM;IACN,MAAM,IAAIrB,qBAAqB,CAAC,yBAAyBgC,EAAE,GAAG,CAAC;EACjE;AACF,CAAC;AAED,OAAM,SAAUgC,gBAAgBA,CAAE9C,GAAW;EAC3C,IAAI;IACF,MAAM0C,GAAG,GAAG,IAAIC,GAAG,CAAC,WAAW3C,GAAG,GAAG,CAAC;IAEtC,OAAO0C,GAAG,CAACE,QAAQ,CAACC,SAAS,CAAC,CAAC,EAAEH,GAAG,CAACE,QAAQ,CAACzC,MAAM,GAAG,CAAC,CAAC;EAC3D,CAAC,CAAC,MAAM;IACN,MAAM,IAAIrB,qBAAqB,CAAC,yBAAyBkB,GAAG,GAAG,CAAC;EAClE;AACF;AAEA,MAAM+C,QAAQ,GAAGC,MAAM,CAACC,MAAM,CAAC1E,KAAK,CAAC,CAAC2E,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,OAAO,CAAC;AAC3D,MAAMC,cAAc,GAAI;EACtB,IAAIC,GAAG,GAAGP,QAAQ,CAAC,CAAC,CAAC,CAACQ,EAAE,CAACR,QAAQ,CAAC,CAAC,CAAC,CAAC;EACrCA,QAAQ,CAACS,KAAK,CAAC,CAAC,CAAC,CAACvC,OAAO,CAAEwC,CAAC,IAAMH,GAAG,GAAGA,GAAG,CAACC,EAAE,CAACE,CAAC,CAAE,CAAC;EACnD,OAAOH,GAAG;AACZ,CAAC,CAAC,CAAE;AAEJ,OAAM,SAAUI,QAAQA,CAAEC,KAAa;EACrC,OAAON,cAAc,CAAC7C,MAAM,CAACmD,KAAK,CAAC;AACrC;AAEA,OAAM,SAAUC,QAAQA,CAAE5E,IAAyB;EACjD,OAAQC,GAAG,IAAI;IACb,OAAOD,IAAI,CAAC6E,OAAO,CAACC,MAAM,CAAC7E,GAAG,CAAC;EACjC,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}